/******************************************************************************
    Copyright (C) 2026 Uniflow, Inc.
    Author: Kim Taehyung <gaiaengine@gmail.com>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
******************************************************************************/

/******************************************************************************
    Modifications Copyright (C) 2026 Uniflow, Inc.
    Author: Kim Taehyung <gaiaengine@gmail.com>
    Modified: 2026-02-16
    Notes: Changes for Syndy Creator Studio.
******************************************************************************/

uniform texture2d effect_base_color_param;
uniform float4x4 ViewProj;
uniform float3 effect_camera_position = {0.0, 0.0, -3.0};
uniform float4 effect_solid_base_color = {0.36, 0.36, 0.38, 1.0};
uniform float4 effect_wireframe_color = {0.0, 0.0, 0.0, 1.0};
uniform float effect_wireframe_thickness = 1.2;
uniform float3 effect_light_direction = {-0.35, -0.65, -0.70};
uniform float effect_ambient_strength = 0.32;
uniform float effect_diffuse_strength = 0.82;
uniform float effect_specular_strength = 0.28;
uniform float effect_shininess = 24.0;

sampler_state linear_sampler {
	Filter = Linear;
	AddressU = Clamp;
	AddressV = Clamp;
};

struct VertDataFill {
	float4 pos : POSITION;
	float3 normal : NORMAL;
	float2 uv : TEXCOORD0;
};

struct VertDataWire {
	float4 pos : POSITION;
	float3 normal : NORMAL;
	float2 uv : TEXCOORD0;
	float4 bary : TEXCOORD1;
};

struct VertDataOut {
	float4 pos : POSITION;
	float3 world_pos : TEXCOORD1;
	float3 normal : TEXCOORD2;
	float2 uv : TEXCOORD0;
};

struct WireDataOut {
	float4 pos : POSITION;
	float3 world_pos : TEXCOORD1;
	float3 normal : TEXCOORD2;
	float2 uv : TEXCOORD0;
	float3 bary : TEXCOORD3;
};

VertDataOut VSDefault(VertDataFill v)
{
	VertDataOut v_out;
	v_out.world_pos = v.pos.xyz;
	v_out.normal = v.normal;
	v_out.uv = v.uv;
	v_out.pos = mul(float4(v.pos.xyz, 1.0), ViewProj);
	return v_out;
}

WireDataOut VSWireframe(VertDataWire v)
{
	WireDataOut v_out;
	v_out.world_pos = v.pos.xyz;
	v_out.normal = v.normal;
	v_out.uv = v.uv;
	v_out.bary = v.bary.xyz;
	v_out.pos = mul(float4(v.pos.xyz, 1.0), ViewProj);
	return v_out;
}

float3 BlinnPhongLight(float3 albedo, float3 normal, float3 world_pos)
{
	float normal_len_sq = dot(normal, normal);
	float3 n = normal_len_sq > 1e-6 ? normalize(normal) : float3(0.0, 0.0, 1.0);
	float3 l = normalize(-effect_light_direction);
	float3 v = normalize(effect_camera_position - world_pos);
	float3 h = normalize(l + v);
	float ndotl = saturate(dot(n, l));
	float spec = pow(saturate(dot(n, h)), max(effect_shininess, 1.0));
	float3 ambient = albedo * effect_ambient_strength;
	float3 diffuse = albedo * (effect_diffuse_strength * ndotl);
	float3 specular = effect_specular_strength * spec;
	return ambient + diffuse + specular;
}

float4 ResolveBaseColor(VertDataOut v)
{
	v.uv += 0.0;
	return effect_solid_base_color;
}

float4 PSBlinnPhongWireframe(VertDataOut v) : TARGET
{
	float4 base_color = ResolveBaseColor(v);
	float3 lit_color = BlinnPhongLight(base_color.rgb, v.normal, v.world_pos);
	return float4(lit_color, base_color.a);
}

float wire_edge_alpha(float3 bary)
{
	float3 fw = fwidth(bary);
	float3 edge = smoothstep(float3(0.0, 0.0, 0.0), fw * effect_wireframe_thickness, bary);
	return saturate(1.0 - min(edge.x, min(edge.y, edge.z)));
}

float4 PSWireframe(WireDataOut v) : TARGET
{
	float alpha = wire_edge_alpha(v.bary) * effect_wireframe_color.a;

	if (alpha < 0.001f)
		discard;

	return float4(effect_wireframe_color.rgb, alpha);
}

technique DrawBlinnPhongWireframe
{
	pass
	{
		vertex_shader = VSDefault(v);
		pixel_shader = PSBlinnPhongWireframe(v);
	}
}

technique DrawWireframe
{
	pass
	{
		vertex_shader = VSWireframe(v);
		pixel_shader = PSWireframe(v);
	}
}
